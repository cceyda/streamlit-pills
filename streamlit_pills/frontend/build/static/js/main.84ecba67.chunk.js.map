{"version":3,"sources":["index.tsx"],"names":["labelDiv","document","body","appendChild","createElement","label","createTextNode","container","classList","add","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","textContent","args","options","icons","index","multiselect","label_visibility","clearable","style","visibility","display","childNodes","length","forEach","option","i","pill","icon_span","includes","onclick","contains","remove","ind","indexOf","splice","querySelectorAll","el","push","setComponentValue","theme","font","color","textColor","base","setFrameHeight","setComponentReady"],"mappings":"mJAAA,kBAEMA,EAAWC,SAASC,KAAKC,YAAYF,SAASG,cAAc,UAC5DC,EAAQL,EAASG,YAAYF,SAASK,eAAe,KACrDC,EAAYN,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACnEG,EAAUC,UAAUC,IAAI,aAgGxBC,IAAUC,OAAOC,iBAAiBF,IAAUG,cAzF5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAEhDX,EAAMY,YAAcF,EAAKG,KAAL,MACpB,IAAIC,EAAUJ,EAAKG,KAAL,QACVE,EAAQL,EAAKG,KAAL,MACRG,EAAQN,EAAKG,KAAL,MACRI,EAAcP,EAAKG,KAAL,YACdK,EAAmBR,EAAKG,KAAL,iBACnBM,EAAYT,EAAKG,KAAL,UAGS,WAArBK,IACFvB,EAASyB,MAAMC,WAAa,UAEL,cAArBH,IACFvB,EAASyB,MAAME,QAAU,QAGS,IAAhCpB,EAAUqB,WAAWC,QACvBV,EAAQW,SAAQ,SAACC,EAAgBC,GAC/B,IAAIC,EAAO1B,EAAUJ,YAAYF,SAASG,cAAc,QAGxD,GAFA6B,EAAKzB,UAAUC,IAAI,QAEfW,EAAO,CACT,IAAIc,EAAYD,EAAK9B,YAAYF,SAASG,cAAc,SACxD8B,EAAU1B,UAAUC,IAAI,QACxByB,EAAUjB,YAAcG,EAAMY,GAGhCC,EAAK9B,YAAYF,SAASK,eAAeyB,IAErCV,EAAMc,SAASH,IACjBC,EAAKzB,UAAUC,IAAI,YAGrBwB,EAAKG,QAAU,WAKb,GADeZ,GAAaS,EAAKzB,UAAU6B,SAAS,YACtC,CACZJ,EAAKzB,UAAU8B,OAAO,YACtB,IAAIC,EAAMlB,EAAMmB,QAAQR,IACX,IAATO,GACFlB,EAAMoB,OAAOF,EAAK,QAGfjB,IACHf,EAAUmC,iBAAiB,aAAaZ,SAAQ,SAACa,GAC/CA,EAAGnC,UAAU8B,OAAO,eAEtBjB,EAAM,IAERY,EAAKzB,UAAUC,IAAI,YACnBY,EAAMuB,KAAKZ,GAGbtB,IAAUmC,kBAAkBxB,OAM9BN,EAAK+B,QACP9C,EAASyB,MAAMsB,KAAOhC,EAAK+B,MAAMC,KACjC/C,EAASyB,MAAMuB,MAAQjC,EAAK+B,MAAMG,UACV,SAApBlC,EAAK+B,MAAMI,KACbjD,SAASC,KAAKwC,iBAAiB,SAASZ,SAAQ,SAACa,GAC/CA,EAAGnC,UAAUC,IAAI,WAGnBR,SAASC,KAAKwC,iBAAiB,SAASZ,SAAQ,SAACa,GAC/CA,EAAGnC,UAAU8B,OAAO,YAW1B5B,IAAUyC,oBAQZzC,IAAU0C,oBAIV1C,IAAUyC,mB","file":"static/js/main.84ecba67.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\nconst labelDiv = document.body.appendChild(document.createElement(\"label\"))\nconst label = labelDiv.appendChild(document.createTextNode(\"\"))\nconst container = document.body.appendChild(document.createElement(\"div\"))\ncontainer.classList.add(\"container\")\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  label.textContent = data.args[\"label\"]\n  let options = data.args[\"options\"]\n  let icons = data.args[\"icons\"]\n  let index = data.args[\"index\"]\n  let multiselect = data.args[\"multiselect\"]\n  let label_visibility = data.args[\"label_visibility\"]\n  let clearable = data.args[\"clearable\"]\n  // console.log(captions)\n\n  if (label_visibility === \"hidden\") {\n    labelDiv.style.visibility = \"hidden\"\n  }\n  if (label_visibility === \"collapsed\") {\n    labelDiv.style.display = \"none\"\n  }\n\n  if (container.childNodes.length === 0) {\n    options.forEach((option: string, i: number) => {\n      let pill = container.appendChild(document.createElement(\"div\"))\n      pill.classList.add(\"pill\")\n\n      if (icons) {\n        let icon_span = pill.appendChild(document.createElement(\"span\"))\n        icon_span.classList.add(\"icon\")\n        icon_span.textContent = icons[i]\n      }\n\n      pill.appendChild(document.createTextNode(option))\n\n      if (index.includes(i)) {\n        pill.classList.add(\"selected\")\n      }\n\n      pill.onclick = function () {\n        // If the element is clearable, let the user unselect by clicking on the pill\n        // again. I.e. if this pill (which is clicked) was already selected before, we\n        // unselect it later.\n        let unselect = clearable && pill.classList.contains(\"selected\")\n        if (unselect) {\n          pill.classList.remove(\"selected\")\n          var ind = index.indexOf(i);\n          if (ind !== -1) {\n            index.splice(ind, 1);\n          }\n        }else{\n          if (!multiselect){\n            container.querySelectorAll(\".selected\").forEach((el) => {\n              el.classList.remove(\"selected\")\n            })\n            index=[]\n          }\n          pill.classList.add(\"selected\")\n          index.push(i)\n        }\n        \n        Streamlit.setComponentValue(index) \n      }\n    })\n  }\n\n  // Style according to the app theme.\n  if (data.theme) {\n    labelDiv.style.font = data.theme.font\n    labelDiv.style.color = data.theme.textColor\n    if (data.theme.base === \"dark\") {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.add(\"dark\")\n      })\n    } else {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.remove(\"dark\")\n      })\n    }\n\n    // TODO: Gray out the component and disable click if it's disabled.\n  }\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}